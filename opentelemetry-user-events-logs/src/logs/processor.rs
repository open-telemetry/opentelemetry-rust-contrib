use opentelemetry::InstrumentationScope;
use opentelemetry_sdk::logs::LogExporter;
use opentelemetry_sdk::Resource;
use opentelemetry_sdk::{
    error::OTelSdkResult,
    logs::{LogBatch, SdkLogRecord},
};
use std::fmt::Debug;

use crate::logs::exporter::UserEventsExporter;

/// Processes and exports logs to User Events.
///
/// This processor exports logs without synchronization.
/// It is specifically designed for the User Events exporter, where
/// the underlying exporter is safe under concurrent calls.
#[derive(Debug)]
pub struct Processor {
    exporter: UserEventsExporter,
}

impl Processor {
    /// Creates a builder for configuring a User Events Processor
    pub fn builder(provider_name: &str) -> ProcessorBuilder {
        ProcessorBuilder::new(provider_name)
    }
}

impl opentelemetry_sdk::logs::LogProcessor for Processor {
    fn emit(&self, record: &mut SdkLogRecord, scope: &InstrumentationScope) {
        let log_tuple = &[(record as &SdkLogRecord, scope)];
        // TODO: Using futures_executor::block_on can make the code non reentrant safe
        // if that crate starts emitting logs that are bridged to OTel.
        // TODO: How to log if export() returns Err? Maybe a metric?
        // Alternately, we can enter a SuppressionContext and log the error
        // if the result is an error (once upstream ships SuppressionContext).
        let _ = futures_executor::block_on(self.exporter.export(LogBatch::new(log_tuple)));
    }

    // Nothing to flush as this processor does not buffer
    fn force_flush(&self) -> OTelSdkResult {
        Ok(())
    }

    fn shutdown(&self) -> OTelSdkResult {
        self.exporter.shutdown()
    }

    #[cfg(feature = "spec_unstable_logs_enabled")]
    fn event_enabled(
        &self,
        level: opentelemetry::logs::Severity,
        target: &str,
        name: Option<&str>,
    ) -> bool {
        self.exporter.event_enabled(level, target, name)
    }

    fn set_resource(&mut self, resource: &Resource) {
        self.exporter.set_resource(resource);
    }
}

/// Builder for configuring and constructing a User Events Processor
#[derive(Debug)]
pub struct ProcessorBuilder<'a> {
    provider_name: &'a str,
}

impl<'a> ProcessorBuilder<'a> {
    /// Creates a new builder with the given provider name
    ///
    /// The provider name must:
    /// - Not be empty.
    /// - Be less than 234 characters.
    /// - Contain only ASCII letters, digits, and the underscore (`'_'`) character.
    /// - Be short, human-readable, and unique enough to avoid conflicts with other provider names.
    /// - Typically include a company name and a component name, e.g., "MyCompany_MyComponent".    
    ///
    /// Tracepoint names are generated by combining the provider name, event
    /// level and keyword (currently hardcoded to `1`) in the following format:
    /// `ProviderName + '_' + 'L' + EventLevel + 'K' + EventKeyword`
    ///
    /// For example, if "myprovider" is the provider name, the following tracepoint names are created:
    /// - `myprovider_L5K1`
    /// - `myprovider_L4K1`
    /// - `myprovider_L3K1`
    /// - `myprovider_L2K1`
    /// - `myprovider_L1K1`
    ///
    /// perf tool can be used to record events from the tracepoints.
    /// For example the following will capture level 2 (Error) and 3(Warning) events:
    /// perf record -e user_events:myprovider_L2K1,user_events:myprovider_L3K1
    pub(crate) fn new(provider_name: &'a str) -> Self {
        Self { provider_name }
    }

    /// Builds the processor with the configured options
    ///
    /// # Returns
    ///
    /// A result containing the configured `Processor` or an error string if validation fails.
    // TODO: Custom error struct instead of a string.
    pub fn build(self) -> Result<Processor, String> {
        // Validate provider name
        if self.provider_name.is_empty() {
            return Err("Provider name cannot be empty.".to_string());
        }
        if self.provider_name.len() >= 234 {
            return Err("Provider name must be less than 234 characters.".to_string());
        }
        if !self
            .provider_name
            .chars()
            .all(|c| c.is_ascii_alphanumeric() || c == '_')
        {
            return Err(
                "Provider name must contain only ASCII letters, digits, and '_'.".to_string(),
            );
        }

        let exporter = UserEventsExporter::new(self.provider_name);
        Ok(Processor { exporter })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_processor_builder_with_valid_provider() {
        let processor = Processor::builder("test_provider").build();
        assert!(processor.is_ok());
    }

    #[test]
    fn test_processor_builder_with_empty_provider_name() {
        let processor = Processor::builder("").build();
        assert!(processor.is_err());
        assert_eq!(processor.unwrap_err(), "Provider name cannot be empty.");
    }

    #[test]
    fn test_processor_builder_with_long_provider_name() {
        let long_name = "a".repeat(234);
        let processor = Processor::builder(&long_name).build();
        assert!(processor.is_err());
    }

    #[test]
    fn test_processor_builder_with_invalid_chars() {
        let invalid_name = "test-provider";
        let processor = Processor::builder(invalid_name).build();
        assert!(processor.is_err());
    }

    #[test]
    fn valid_provider_name() {
        let valid_names = vec![
            "ValidName",
            "valid_name",
            "Valid123",
            "valid_123",
            "_valid_name",
            "VALID_NAME",
        ];

        for valid_name in valid_names {
            let processor = Processor::builder(valid_name).build();
            assert!(processor.is_ok());
        }
    }

    #[test]
    fn provider_name_contains_invalid_characters() {
        // Define a vector of invalid provider names to test
        let invalid_names = vec![
            "Invalid Name",  // space
            "Invalid:Name",  // colon
            "Invalid\0Name", // null character
            "Invalid-Name",  // hyphen
            "InvalidName!",  // exclamation mark
            "InvalidName@",  // at symbol
            "Invalid+Name",  // plus
            "Invalid&Name",  // ampersand
            "Invalid#Name",  // hash
            "Invalid%Name",  // percent
            "Invalid/Name",  // slash
            "Invalid\\Name", // backslash
            "Invalid=Name",  // equals
            "Invalid?Name",  // question mark
            "Invalid;Name",  // semicolon
            "Invalid,Name",  // comma
        ];

        // Expected error message
        let expected_error =
            "Provider name must contain only ASCII letters, digits, and '_'.".to_string();

        // Test each invalid name
        for invalid_name in invalid_names {
            let options = Processor::builder(invalid_name).build();
            // Assert that the result is an error
            assert!(
                options.is_err(),
                "Expected '{}' to be invalid, but it was accepted",
                invalid_name
            );

            // Assert that the error message is as expected
            assert_eq!(
                options.err().unwrap(),
                expected_error,
                "Wrong error message for invalid name: '{}'",
                invalid_name
            );
        }
    }
}
